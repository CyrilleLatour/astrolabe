<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Analog Watch - Mobile Frame</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-title" content="WorldWatch">
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#111111">
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap" rel="stylesheet">
  <style>
    
    html, body { height:100%; margin:0; background:#e9ecef; display:grid; place-items:center; font-family:Arial,Helvetica,sans-serif; }

    .phone {
      position:relative; width:min(390px,92vw); aspect-ratio:9/19.5; background:#f8f9fa;
      border: 16px solid #f8f9fa; #111; border-radius:34px; box-shadow:0 20px 60px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.06); overflow:hidden;
    }

    .screen { position:absolute; inset:20px 14px 20px; display:grid; grid-template-rows:auto 1fr auto; align-items:start; row-gap:0; }

    .header { position:relative; height:44px; display:flex; align-items:center; justify-content:center; }
    .city-name { font-weight:700; font-size:30px; color:blue; pointer-events:none; }
    .tz-button {
      position:absolute; right:10px; top:8px; font-size:15px; padding:8px 10px;
      border:1px solid #000; background:#fff; color:#000; border-radius:8px; cursor:pointer; user-select:none; z-index:20;
    }
    .tz-button:hover { background:red; border-color:red; color:#fff; }

    .tz-menu {
      position:absolute; right:0; top:44px; width:240px; background:#fff; border:1px solid #000; border-radius:8px;
      box-shadow:0 8px 24px rgba(0,0,0,.15); z-index:1000; overflow:hidden; display:none;
    }
    .tz-menu.show { display:block; }
    .tz-menu-header { padding:8px 10px; font-size:12px; font-weight:600; background:#f1f1f1; border-bottom:1px solid #000; }
    .tz-menu-list { max-height:320px; overflow-y:auto; -webkit-overflow-scrolling:touch; overscroll-behavior:contain; }
    .tz-item {
      height:32px; line-height:32px; padding:0 10px; font-size:13px; cursor:pointer; white-space:nowrap;
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      color:#000; font-weight:400;
    }
    .tz-item.is-capital { color:red; font-weight:700; }

    .tz-item:hover,.tz-item:focus { background:#e9f2ff; outline:none; }
    .tz-item.active { background:#d7ecff; }
    .tz-cc { font-size:12px; color:#333; opacity:.85; flex:0 0 auto; }

    .center-pane { position:relative; display:grid; align-content:start; justify-items:center; padding-top:25px; }
    .watch { position:relative; width:300px; height:300px; border:8px solid #000; border-radius:50%; top:-0px; left:-5px; background:#fff; overflow:hidden; }
    .hand { position:absolute; bottom:50%; left:50%; transform:translateX(-50%) rotate(0deg); transform-origin:bottom center; background:#000; }
    .hand.hour{ width:6px; height:70px; z-index:10; } .hand.minute{ width:6px; height:105px; z-index:9; }
    .hand.second{ width:2px; height:120px; z-index:20; background:#e00; }
    .center-dot{ position:absolute; width:14px; height:14px; background:#000; border-radius:50%; top:50%; left:50%; transform:translate(-50%,-50%); z-index:20; }
    .dot{ position:absolute; width:10px; height:10px; background:#000; border-radius:50%; }
    .min-dot{ position:absolute; width:5px; height:5px; background:#000; border-radius:50%; opacity:.9; }
    .mark-wrap{ position:absolute; left:50%; top:50%; transform-origin:center center; }
    .main-mark{
      position:absolute; left:50%; top:50%; width:6px; height:30px; background:#000; border-radius:3px;
      transform-origin:50% 100%; transform:translate(-50%, var(--edge-translate,-150px));
    }
    .digital{ position:absolute; left:50%; top:58%; transform:translateX(-50%); font:14px/1 Arial,sans-serif; color:#111; z-index:20; }

    .box{
      display:inline-flex; align-items:center; justify-content:center; background:#fff; color:#000; border:1px solid #000; border-radius:4px;
      font:12px/1 Arial,sans-serif; white-space:nowrap; z-index:5;
    }
    .day-box{ position:absolute; top:50%; left:85%; transform:translate(-50%,-50%); width:20px; height:20px; }
    .week-box{ position:absolute; top:50%; left:75%; transform:translate(-50%,-50%); text-transform:lowercase; width:24px; height:20px; padding: 0px 2px 0px 2px }
    .month-cluster{ position:absolute; top:50%; left:25%; transform:translate(-50%, -50%); display:inline-flex; align-items:center; gap:6px; z-index:5; }
    .month-box{ width:30px; height:20px; } .week-label{ font:11px/1 Arial,sans-serif; color:#000; user-select:none; } .weeknum-box{ width:20px; height:20px; }
    .hour-num{ position:absolute; transform:translate(-50%,-50%); font-family:'Comic Neue','Comic Sans MS','Comic Sans',cursive; font-weight:700; color:blue; line-height:1; user-select:none; pointer-events:none; }

      contain: layout paint;}
    

    .tz-item.is-capital, .diff-item.is-capital { color: red; font-weight: 700; }

#city {
    position: relative;
    top: -15px; /* Ajuste cette valeur (ex: -20px, -30px) */
}

#tzBtn {
    transform: translateY(-15px); /* Monte de 15px SANS bouger Ã  gauche/droite */
    margin-right:
  }


</style>
</head>

<body>
  
  <div class="phone" id="phone">
    <div class="screen">
      <div class="header">
        <div class="city-name" id="city">Geneva</div>
        <button class="tz-button" type="button" id="tzBtn" aria-haspopup="listbox" aria-expanded="false">town</button>

        <div class="tz-menu" id="tzMenu" role="listbox" aria-label="Choose a town">
          <div class="tz-menu-header">
            <input id="tzSearch" type="text" placeholder="Search a town..."
              style="width:100%; box-sizing:border-box; font-size:12px; padding:6px 8px; border:1px solid #000; border-radius:6px;">
          </div>
          <div class="tz-menu-list" id="tzList"></div>
        </div>
      </div>

      <div class="center-pane">
        <div class="watch" id="watch">
          <div class="hand hour" id="hour"></div>
          <div class="hand minute" id="minute"></div>
          <div class="hand second" id="second"></div>
          <div class="center-dot"></div>
          <div class="digital" id="digital"></div>

          <svg style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
            <circle cx="50%" cy="115px" r="50" fill="black"/>
            <circle cx="50%" cy="115px" r="41" fill="yellow" />
          </svg>

          <div class="week-box box" id="week"></div>
          <div class="day-box box" id="day"></div>

          <div class="month-cluster" id="monthCluster">
            <div class="month-box box" id="month"></div><div class="week-label">week</div><div class="weeknum-box box" id="weeknum"></div>
          </div>
        </div>
      </div>

      <div class="footer">
       

       
          <div class="diff-row" id="diffRow">
            <!-- Suppression propre du bouton + patch JS -->
          <span id="diffOutput" style="display: inline-block;"></span>
          <script>
          // Patch pour Ã©viter les erreurs JS
          window.diffBtn = {
              addEventListener: () => {},
              removeEventListener: () => {},
              click: () => {},
              dispatchEvent: () => true,
              style: { display: 'none' }
          };
          </script>

            <span id="diffOutput"></span>           
          </div>


        </div>
      </div>
    </div>
  </div>

<script>
    // Buffer to store towns coordinates before map init
    window.__CITY_COORDS_BUFFER = window.__CITY_COORDS_BUFFER || {};

    let funTimerId=null,isAnimating=false,lastAngles={h:0,m:0,s:0};
    let prevSecond = null;

    function pulseMarker(){
      const el = document.querySelector('.city-marker');
      if (!el) return;
      if (window.__isAnimatingMarker) {
        el.classList.remove('pulse');
        return;
      }
      if (!el.classList.contains('pulse')) el.classList.add('pulse');
    }

    function queueFunAnimation(d=500){ clearTimeout(funTimerId); funTimerId=setTimeout(startFunAnimation,d); }
    function mod360(x){ return ((x%360)+360)%360; }

    const phone=document.getElementById('phone'), watch=document.getElementById('watch');

    function layoutWatch(){
      const screen=phone.querySelector('.screen'), header=phone.querySelector('.header'), footer=phone.querySelector('.footer');
      const sr=screen.getBoundingClientRect(), hr=header.getBoundingClientRect(), fr=footer.getBoundingClientRect();
      const verticalPadding=12, availableW=sr.width-8, availableH=sr.height-hr.height-fr.height-verticalPadding*2;
      const size=Math.floor(Math.min(availableW,availableH)); 
      watch.style.width=size+'px'; watch.style.height=size+'px';
      drawMarks(size); drawHourNumbers(size);
    }

    function drawMarks(size){
      watch.querySelectorAll('.dot,.min-dot,.mark-wrap').forEach(n=>n.remove());
      const CENTER=size/2, RADIUS_MARKS=size*.45, RADIUS_EDGE=size/2;
      watch.style.setProperty('--edge-translate',(-RADIUS_EDGE)+'px');
      for(let i=0;i<12;i++){
        const deg=i*30;
        if(i===0||i===3||i===6||i===9){
          const w=document.createElement('div'); w.className='mark-wrap'; w.style.transform=`translate(-50%,-50%) rotate(${deg}deg)`;
          const m=document.createElement('div'); m.className='main-mark'; w.appendChild(m); watch.appendChild(w);
        } else {
          const d=document.createElement('div'); d.className='dot';
          const rad=(deg-90)*Math.PI/180;
          const x=CENTER+RADIUS_MARKS*Math.cos(rad)-5, y=CENTER+RADIUS_MARKS*Math.sin(rad)-5;
          d.style.left=`${x}px`; d.style.top=`${y}px`; watch.appendChild(d);
        }
      }
      for(let m=0;m<60;m++){ 
        if(m%5===0) continue;
        const deg=m*6, rad=(deg-90)*Math.PI/180;
        const md=document.createElement('div'); md.className='min-dot';
        const x=CENTER+RADIUS_MARKS*Math.cos(rad)-2.5, y=CENTER+RADIUS_MARKS*Math.sin(rad)-2.5;
        md.style.left=`${x}px`; md.style.top=`${y}px`; watch.appendChild(md);
      }
    }

    function drawHourNumbers(size){
      watch.querySelectorAll('.hour-num').forEach(n=>n.remove());
      const CENTER=size/2, RADIUS_NUM=size*.36, fontPx=Math.max(12,Math.round(size*.08));
      for(let h=1;h<=12;h++){ 
        if(h===3||h===9) continue;
        const deg=h*30, rad=(deg-90)*Math.PI/180, x=CENTER+RADIUS_NUM*Math.cos(rad), y=CENTER+RADIUS_NUM*Math.sin(rad);
        const el=document.createElement('div'); el.className='hour-num'; el.textContent=(h===12)?'12':String(h);
        el.style.left=`${x}px`; el.style.top=`${y}px`; el.style.fontSize=`${fontPx}px`; watch.appendChild(el);
      }
    }

    const __CAPITAL_NAME_SET = new Set();
    const __CAPITAL_COORDS = {};
    const TIMEZONE_MAP = {};
    const CITY_LIST = [];
    let SORTED = [];
    let currentTZ="Europe/Zurich";
    let lastSunKey=null;

    function getPartsForTZ(tz){
      const now=new Date();
      const t=new Intl.DateTimeFormat('en-GB',{timeZone:tz,hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false}).formatToParts(now);
      const H=parseInt(t.find(p=>p.type==='hour').value,10), M=parseInt(t.find(p=>p.type==='minute').value,10), S=parseInt(t.find(p=>p.type==='second').value,10);
      const d=new Intl.DateTimeFormat('en-GB',{timeZone:tz,year:'numeric',month:'2-digit',day:'2-digit',weekday:'short'}).formatToParts(now);
      const Y=parseInt(d.find(p=>p.type==='year').value,10), Mo=parseInt(d.find(p=>p.type==='month').value,10), D=parseInt(d.find(p=>p.type==='day').value,10);
      let wd=d.find(p=>p.type==='weekday').value.toLowerCase().slice(0,3);
      return {H,M,S,Y,Mo,D,wd};
    }

    function isoWeekOf(y,m,d){
      const date=new Date(Date.UTC(y,m-1,d)); const dayNum=(date.getUTCDay()+6)%7+1;
      date.setUTCDate(date.getUTCDate()+4-dayNum); const yearStart=new Date(Date.UTC(date.getUTCFullYear(),0,1));
      return Math.ceil((((date-yearStart)/86400000)+1)/7);
    }

    function saveTZState(city,tz){ try{ localStorage.setItem('tzState',JSON.stringify({city,tz})); }catch{} }
    function loadTZState(){ try{ return JSON.parse(localStorage.getItem('tzState')||'null'); }catch{ return null; } }

    function updateClockTZ(){
      const {H,M,S}=getPartsForTZ(currentTZ); const sDeg=S*6;
      document.getElementById('second').style.transform=`translateX(-50%) rotate(${sDeg}deg)`; lastAngles.s=sDeg;
      document.getElementById('digital').textContent=`${String(H).padStart(2,'0')}:${String(M).padStart(2,'0')}:${String(S).padStart(2,'0')}`;
      if(isAnimating) return;
      const mDeg=M*6+S*0.1, hDeg=(H%12)*30+M*0.5;
      document.getElementById('minute').style.transform=`translateX(-50%) rotate(${mDeg}deg)`;
      document.getElementById('hour').style.transform=`translateX(-50%) rotate(${hDeg}deg)`;
      lastAngles.m=mDeg; lastAngles.h=hDeg;
    }

    function updateCalendarTZ(){
      const months=["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"];
      const {Y,Mo,D,wd}=getPartsForTZ(currentTZ);
      document.getElementById('week').textContent=wd;
      document.getElementById('day').textContent=String(D);
      document.getElementById('month').textContent=months[Mo-1];
      document.getElementById('weeknum').textContent=String(isoWeekOf(Y,Mo,D));
    }

    function startFunAnimation(){
      const DURATION=1200, EASE='cubic-bezier(.25,.9,.3,1)';
      const LEAD_MS = 120;
      const {H,M,S}=getPartsForTZ(currentTZ);
      const targetMinute=M*6+S*0.1, targetHour=(H%12)*30+M*0.5;
      const hourEl=document.getElementById('hour'), minuteEl=document.getElementById('minute');
      hourEl.style.transition='none'; minuteEl.style.transition='none';
      hourEl.style.transform=`translateX(-50%) rotate(${lastAngles.h}deg)`; minuteEl.style.transform=`translateX(-50%) rotate(${lastAngles.m}deg)`;
      const deltaHcw=mod360(targetHour-lastAngles.h), endH=lastAngles.h+360+deltaHcw;
      const deltaMccw=-mod360(lastAngles.m-targetMinute), endM=lastAngles.m-360+deltaMccw;
      requestAnimationFrame(()=>{
        isAnimating=true;
        setTimeout(()=>pulseMarker(true), Math.max(0, DURATION - LEAD_MS));
        hourEl.style.transition=`transform ${DURATION}ms ${EASE}`;
        minuteEl.style.transition=`transform ${DURATION}ms ${EASE}`;
        hourEl.style.transform=`translateX(-50%) rotate(${endH}deg)`;
        minuteEl.style.transform=`translateX(-50%) rotate(${endM}deg)`;
        setTimeout(()=>{
          hourEl.style.transition='none'; minuteEl.style.transition='none';
          const hFinal=mod360(targetHour), mFinal=mod360(targetMinute);
          hourEl.style.transform=`translateX(-50%) rotate(${hFinal}deg)`; minuteEl.style.transform=`translateX(-50%) rotate(${mFinal}deg)`;
          lastAngles.h=hFinal; lastAngles.m=mFinal; isAnimating=false;
        }, DURATION+30);
      });
    }

    function tick(){
      updateClockTZ();
      updateCalendarTZ();

      const { Y, Mo, D, S } = getPartsForTZ(currentTZ);
      const key = `${Y}-${Mo}-${D}`;
      if (key !== lastSunKey) {
        lastSunKey = key;
        if (window.updateSunTimes) window.updateSunTimes(document.getElementById('city').textContent.trim());
      }

      if (prevSecond === null){ prevSecond = S; pulseMarker();
      } else if (S !== prevSecond){ prevSecond = S; pulseMarker(); }
      scheduleNextTick();
    }
    function scheduleNextTick(){ const delay = 1000 - (Date.now() % 1000) + 2; setTimeout(tick, delay); }

    const tzBtn=document.getElementById('tzBtn'), tzMenu=document.getElementById('tzMenu'), tzList=document.getElementById('tzList'), tzSearch=document.getElementById('tzSearch'), cityEl=document.getElementById('city');

    window.__skipNextCityMutation = false;
    window.__isAnimatingMarker = false;

    function __mergeCapitalIntoBase(city){
      const n = city.name;
      if (!n) return;
      __CAPITAL_NAME_SET.add(n);
      if (!CITY_LIST.some(c => c.name === n)){
        CITY_LIST.push({ name: n, cc: city.cc || "" });
      }
      if (city.tz && !TIMEZONE_MAP[n]) {
        TIMEZONE_MAP[n] = city.tz;
      }
      if (typeof city.lon === "number" && typeof city.lat === "number"){
        __CAPITAL_COORDS[n] = [city.lon, city.lat];
      // buffer as well so map can pick it later if not ready yet
      window.__CITY_COORDS_BUFFER[n] = [city.lon, city.lat];
      if (typeof window.__mergeCapitalCoordsIntoMap === "function"){
        const one = {}; one[n] = [city.lon, city.lat];
        window.__mergeCapitalCoordsIntoMap(one);
      }
}
    }

    function __mergeTownIntoBase(city){
      const n = city.name;
      if (!n) return;
      if (!CITY_LIST.some(c => c.name === n)){
        CITY_LIST.push({ name: n, cc: city.cc || "" });
      }
      if (city.tz && !TIMEZONE_MAP[n]) {
        TIMEZONE_MAP[n] = city.tz;
      }
      if (typeof city.lon === "number" && typeof city.lat === "number"){
        // push coords immediately if map already defined the merge function
        if (typeof window.__mergeCapitalCoordsIntoMap === "function"){
          const one = {}; one[n] = [city.lon, city.lat];
          window.__mergeCapitalCoordsIntoMap(one);
        }
        // always buffer as well (covers case where map isn't ready yet)
        window.__CITY_COORDS_BUFFER[n] = [city.lon, city.lat];
      }
    }

    function __postMerge(){
      SORTED = CITY_LIST.slice().sort((a,b)=>a.name.localeCompare(b.name,'en',{sensitivity:'base'}));
      // push capitals coords
      if (typeof window.__mergeCapitalCoordsIntoMap === "function" && Object.keys(__CAPITAL_COORDS).length){
        window.__mergeCapitalCoordsIntoMap(__CAPITAL_COORDS);
      }
      // push any towns coords buffered
      if (typeof window.__mergeCapitalCoordsIntoMap === "function" && Object.keys(window.__CITY_COORDS_BUFFER).length){
        window.__mergeCapitalCoordsIntoMap(window.__CITY_COORDS_BUFFER);
      }
        // ðŸ”§ Fusionner le buffer directement dans CITY_COORDS
  if (window.CITY_COORDS && Object.keys(window.__CITY_COORDS_BUFFER).length){
    Object.assign(window.CITY_COORDS, window.__CITY_COORDS_BUFFER);
  }
  __refreshListsIfOpen();
    }

    function __refreshListsIfOpen(){
      try{
        const tzMenuEl = document.getElementById('tzMenu');
        const diffMenuEl = document.getElementById('diffMenu');
        if (tzMenuEl && tzMenuEl.classList.contains('show')) {
          populateTzList(document.getElementById('tzSearch')?.value || "");
        }
        if (diffMenuEl && diffMenuEl.classList.contains('show')) {
          populateDiffList(document.getElementById('diffSearch')?.value || "");
        }
      }catch(e){}
    }

    function populateTzList(filterText=""){
      tzList.innerHTML="";
      const f=filterText.trim().toLowerCase();
      const filtered=SORTED.filter(({name})=>name.toLowerCase().includes(f));

      filtered.forEach(({name,cc})=>{
        const li=document.createElement('div');
        li.className='tz-item';
        li.setAttribute('role','option');
        li.setAttribute('tabindex','0');

        if(__CAPITAL_NAME_SET.has(name)){
          li.classList.add("is-capital");
        }

        const label=document.createElement('span');
        label.textContent=name;
        const ccSpan=document.createElement('span');
        ccSpan.className='tz-cc';
        ccSpan.textContent=`(${cc})`;

        li.appendChild(label);
        li.appendChild(ccSpan);

        li.addEventListener('click', ()=>{
          window.__skipNextCityMutation = true;
          cityEl.textContent=name;
          currentTZ=TIMEZONE_MAP[name]||"Europe/Zurich";
          saveTZState(name,currentTZ);
          updateCalendarTZ();
          updateClockTZ();
          if(window.resetDiff) window.resetDiff();

          tzMenu.classList.remove('show');
          tzBtn.setAttribute('aria-expanded','false');
          isAnimating=true;
          queueFunAnimation(500);
          if (window.animateMarkerTo) setTimeout(()=>window.animateMarkerTo(name, 1200), 500);
        });

        li.addEventListener('keydown', e=>{
          if(e.key==='Enter'||e.key===' '){
            e.preventDefault();
            li.click();
          }
        });

        tzList.appendChild(li);
      });

      const items=[...tzList.querySelectorAll('.tz-item')];
      for(const it of items){
        if(it.firstChild && TIMEZONE_MAP[it.firstChild.textContent]===currentTZ){
          it.classList.add('active');
          break;
        }
      }
    }

    function attachSearchHandler(){ 
      if(!tzSearch) return; 
      tzSearch.value=""; 
      tzSearch.addEventListener('input',()=>populateTzList(tzSearch.value)); 
      setTimeout(()=>tzSearch.focus(),0); 
    }

    function toggleTzMenu(){ 
      const isOpen=tzMenu.classList.toggle('show'); 
      tzBtn.setAttribute('aria-expanded',String(isOpen)); 
      if(isOpen){ populateTzList(); attachSearchHandler(); } 
    }

    document.getElementById('tzBtn').addEventListener('click',e=>{ e.stopPropagation(); toggleTzMenu(); });
    document.addEventListener('click',e=>{ 
      if(tzMenu.classList.contains('show')){ 
        const inside=tzMenu.contains(e.target)||tzBtn.contains(e.target);
        if(!inside){ tzMenu.classList.remove('show'); tzBtn.setAttribute('aria-expanded','false'); } 
      }
    });

    document.addEventListener('keydown',e=>{
      if(!tzMenu.classList.contains('show')) return; 
      const items=[...tzList.querySelectorAll('.tz-item')]; 
      if(!items.length) return;
      const active=document.activeElement; let idx=items.indexOf(active);
      if(e.key==='ArrowDown'){ e.preventDefault(); (items[Math.min(idx+1,items.length-1)]||items[0]).focus(); }
      else if(e.key==='ArrowUp'){ e.preventDefault(); (items[Math.max(idx-1,0)]||items[0]).focus(); }
    });


    function getTZOffsetMinutes(tz){
      const now = new Date();
      const tzDate = new Date(now.toLocaleString('en-US', { timeZone: tz }));
      const utcDate = new Date(now.toLocaleString('en-US', { timeZone: 'UTC' }));
      return Math.round((tzDate - utcDate) / 60000);
    }
    function formatOffset(mins){
      const sign = mins >= 0 ? '+' : '-';
      const a = Math.abs(mins);
      const h = Math.floor(a/60);
      const m = a % 60;
      return m===0 ? `${sign}${h}` : `${sign}${h}:${String(m).padStart(2,'0')}`;
    }
    function computeDiffLabel(targetTZ){
      const cur = getTZOffsetMinutes(currentTZ);
      const tgt = getTZOffsetMinutes(targetTZ);
      return formatOffset(tgt - cur);
    }

    function populateDiffList(filterText=""){
      diffList.innerHTML="";
      const f=filterText.trim().toLowerCase();
      const filtered=SORTED.filter(({name})=>name.toLowerCase().includes(f));

      filtered.forEach(({name,cc})=>{
        const li=document.createElement('div');
        li.className='diff-item';
        li.setAttribute('role','option');
        li.setAttribute('tabindex','0');

        if(__CAPITAL_NAME_SET.has(name)){
          li.classList.add("is-capital");
        }

        const label=document.createElement('span');
        label.textContent=name;
        const ccSpan=document.createElement('span');
        ccSpan.className='diff-cc';
        ccSpan.textContent=`(${cc})`;

        li.appendChild(label);
        li.appendChild(ccSpan);

        li.addEventListener('click', ()=>{
          const tz = TIMEZONE_MAP[name] || "Europe/Paris";
          diffSelection = { name, tz };
          diffMenu.classList.remove('show');
          diffBtn.style.display='none';
          const rb = document.getElementById('resetBtn'); /* visibility removed: relying on display */
          document.getElementById('resetBtn').style.display = 'inline-block';
          diffOutput.textContent = ` ${name}: ${computeDiffLabel(tz)}`;
          diffBtn.setAttribute('aria-expanded','false');
          if (window.updateCompare) window.updateCompare(name);
        });

        li.addEventListener('keydown', e=>{
          if(e.key==='Enter'||e.key===' '){
            e.preventDefault();
            li.click();
          }
        });

        diffList.appendChild(li);
      });
    }

    function attachDiffSearch(){ 
      if(!diffSearch) return; 
      diffSearch.value=""; 
      diffSearch.addEventListener('input',()=>populateDiffList(diffSearch.value)); 
      setTimeout(()=>diffSearch.focus(),0); 
    }
    function toggleDiffMenu(){ 
      const isOpen=diffMenu.classList.toggle('show'); 
      diffBtn.setAttribute('aria-expanded',String(isOpen)); 
      if(isOpen){ populateDiffList(); attachDiffSearch(); } 
    }

    diffBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleDiffMenu(); });
    document.addEventListener('click', (e)=>{ 
      if(diffMenu.classList.contains('show')){ 
        const inside = diffMenu.contains(e.target) || diffBtn.contains(e.target); 
        if(!inside){ diffMenu.classList.remove('show'); diffBtn.setAttribute('aria-expanded','false'); } 
      } 
    });

   

    function guessCityFromTimeZone(tz){
      for(const[city,mapped] of Object.entries(TIMEZONE_MAP))
        if(mapped===tz) return city;
      return null;
    }

    (function initTZ(){
      const saved=loadTZState();
      if(saved && saved.tz){
        currentTZ=saved.tz;
        const enCity = guessCityFromTimeZone(saved.tz) || saved.city || 'Geneva';
        document.getElementById('city').textContent = enCity;
        saveTZState(enCity, currentTZ);
      } else {
        const guessed=Intl.DateTimeFormat().resolvedOptions().timeZone;
        const city=guessCityFromTimeZone(guessed);
        if(city){
          document.getElementById('city').textContent=city;
          currentTZ=TIMEZONE_MAP[city];
          saveTZState(city,currentTZ);
        } else {
          document.getElementById('city').textContent='Geneva';
          currentTZ='Europe/Zurich';
          saveTZState('Geneva',currentTZ);
        }
      }
    })();

    window.__mergeCapitalCoordsIntoMap = function(dict){
      if (!dict) return;
      for (const k in dict){
        if (window.CITY_COORDS) window.CITY_COORDS[k] = dict[k];
      }
    };

    // Load capitals then towns, then post-merge
    fetch("capitals.json")
      .then(r => r.json())
      .then(data => {
        if (Array.isArray(data)){
          data.forEach(__mergeCapitalIntoBase);
        } else if (data && typeof data === "object"){
          Object.values(data).forEach(entry => {
            if (Array.isArray(entry)) entry.forEach(__mergeCapitalIntoBase);
            else if (entry && typeof entry === "object") __mergeCapitalIntoBase(entry);
          });
        }
      })
      .catch(()=>{})
      .then(()=>{
        return fetch("towns/towns.json")
          .then(r=>r.json())
          .then(data=>{
            const arr = Array.isArray(data) ? data
                       : (Array.isArray(data.WorldTowns) ? data.WorldTowns : []);
            arr.forEach(__mergeTownIntoBase);
          })
          .catch(()=>{});
      })
      .then(__postMerge)
      .catch(()=>{});

    window.addEventListener('resize',layoutWatch);
    layoutWatch();
    tick();
  </script>

  <script src="https://unpkg.com/d3@7"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
  <script>
    (async function(){
      const svg=d3.select("#map"); if(svg.empty()) return;
      const width=1200, height=600;

      const projection=d3.geoEquirectangular().rotate([-10,0]).fitExtent([[0,0],[width,height]],{type:"Sphere"});
      const path=d3.geoPath(projection), graticule=d3.geoGraticule10(), g=svg.append("g");

      const defs = svg.append("defs");
      const nightMask = defs.append("mask").attr("id","nightMask");
      nightMask.append("rect").attr("width", width).attr("height", height).attr("fill", "black");
      const nightMaskPath = nightMask.append("path").attr("id","nightMaskPath").attr("fill","white");
      const dayMask = defs.append("mask").attr("id","dayMask");
      dayMask.append("rect").attr("width", width).attr("height", height).attr("fill", "white");
      const dayMaskBlock = dayMask.append("path").attr("id","dayMaskBlock").attr("fill","black");

      function drawFallback(){
        g.selectAll("*").remove();
        g.append("path").attr("class","sphere").attr("d",path({type:"Sphere"}));
        g.append("path").attr("class","graticule").attr("d",path(graticule));
        placeInitialMarker();
      }

      let landGeom=null, bordersMesh=null;

      try{
        g.append("path").attr("class","sphere").attr("d",path({type:"Sphere"}));
        g.append("path").attr("class","graticule").attr("d",path(graticule));

        const world=await fetch("https://unpkg.com/world-atlas@2/countries-50m.json").then(r=>r.json());
        const countries=topojson.feature(world, world.objects.countries);
        const borders=topojson.mesh(world, world.objects.countries, (a,b)=>a!==b);
        const land = topojson.feature(world, world.objects.land);

        landGeom = land;
        if (landGeom) g.append("path").attr("class","coastline").attr("d", path(landGeom));
        bordersMesh = borders;


      const CITY_COORDS = {
        "Geneva":[6.15,46.2],"Bern":[7.4474,46.9481],"Paris":[2.3522,48.8566],"London":[-0.1276,51.5072],
        "Berlin":[13.405,52.52],"Rome":[12.4964,41.9028],"Madrid":[-3.7038,40.4168],"Amsterdam":[4.9041,52.3676],
        "Brussels":[4.3517,50.8503],"Vienna":[16.3738,48.2082],"Prague":[14.4378,50.0755],"Warsaw":[21.0122,52.2297],
        "Stockholm":[18.0686,59.3293],"Oslo":[10.7522,59.9139],"Copenhagen":[12.5683,55.6761],"Helsinki":[24.9384,60.1699],
        "Dublin":[-6.2603,53.3498],"Athens":[23.7275,37.9838],"Lisbon":[-9.1393,38.7223],"Budapest":[19.0402,47.4979],
        "Bucharest":[26.1025,44.4268],"Sofia":[23.3219,42.6977],"Zagreb":[15.9779,45.815],"Ljubljana":[14.5058,46.0569],
        "Bratislava":[17.1077,48.1482],"Tallinn":[24.7536,59.437],"Moscow":[37.6173,55.7558],"Kyiv":[30.5238,50.4547],
        "Ankara":[32.8543,39.9208],"Washington, D.C.":[-77.0369,38.9072],"Ottawa":[-75.6972,45.4215],
        "Mexico City":[-99.1332,19.4326],"Buenos Aires":[-58.3816,-34.6037],"Brasilia":[-47.9292,-15.7801],
        "Santiago":[-70.6693,-33.4489],"Lima":[-77.0428,-12.0464],"Bogota":[-74.0721,4.7110],"Caracas":[-66.9036,10.4806],
        "Tokyo":[139.6917,35.6895],"Beijing":[116.4074,39.9042],"Seoul":[126.978,37.5665],"New Delhi":[77.1025,28.7041],
        "Bangkok":[100.5018,13.7563],"Jakarta":[106.8456,-6.2088],"Manila":[120.9842,14.5995],"Hanoi":[105.8342,21.0278],
        "Singapore":[103.8198,1.3521],"Kuala Lumpur":[101.6869,3.139],"Islamabad":[73.0479,33.6844],
        "Dhaka":[90.4125,23.8103],"Tehran":[51.389,35.6892],"Baghdad":[44.3661,33.3152],"Riyadh":[46.6753,24.7136],
        "Abu Dhabi":[54.3773,24.4539],"Doha":[51.531,25.2854],"Jerusalem":[35.2137,31.7683],"Cairo":[31.2357,30.0444],
        "Nairobi":[36.8219,-1.2921],"Lagos":[3.3792,6.5244],"Abuja":[7.4951,9.0579],"Rabat":[-6.8326,34.0209],
        "Algiers":[3.0506,36.7394],"Pretoria":[28.2293,-25.7461],"Cape Town":[18.4233,-33.9189],
        "Canberra":[149.1281,-35.2835],"Wellington":[174.7772,-41.2866]
      };

      // Merge any buffered towns (e.g., Adelaide) into CITY_COORDS
      if (window.__CITY_COORDS_BUFFER && typeof window.__CITY_COORDS_BUFFER === 'object'){
        for (const k in window.__CITY_COORDS_BUFFER){
          CITY_COORDS[k] = window.__CITY_COORDS_BUFFER[k];
        }
      }

      let currentCityLL=null;

      window.__mergeCapitalCoordsIntoMap = function(dict){
        if (!dict) return;
        for (const k in dict){
          CITY_COORDS[k] = dict[k];
        }
      };

      window.CITY_COORDS = CITY_COORDS;

const dayMs=86400000, rad=Math.PI/180, J1970=2440588, J2000=2451545, e=rad*23.4397, J0=0.0009;
      const toJulian=d=>d/ dayMs - 0.5 + J1970;
      const fromJulian=j=>new Date((j + 0.5 - J1970)*dayMs);
      const toDays=date=>toJulian(date.getTime()) - J2000;
      const solarMeanAnomaly=d=>rad*(357.5291+0.98560028*d);
      const eclipticLongitude=M=>{
        const C=rad*(1.9148*Math.sin(M)+0.02*Math.sin(2*M)+0.0003*Math.sin(3*M));
        const P=rad*102.9372;
        return M+C+P+Math.PI;
      };
      const declination=(L,b=0)=>Math.asin(Math.sin(b)*Math.cos(e)+Math.cos(b)*Math.sin(e)*Math.sin(L));
      const rightAscension=(L,b=0)=>Math.atan2(Math.sin(L)*Math.cos(e)-Math.tan(b)*Math.sin(e), Math.cos(L));
      const hourAngle=(h,phi,d)=>Math.acos((Math.sin(h)-Math.sin(phi)*Math.sin(d))/(Math.cos(phi)*Math.cos(d)));
      const approxTransit=(Ht,lw,n)=>J0+(Ht+lw)/(2*Math.PI)+n;
      const solarTransitJ=(ds,M,L)=>J2000+ds+0.0053*Math.sin(M)-0.0069*Math.sin(2*L);

      function getSunTimes(dateUTC, lat, lon){
        const lw = -lon*rad, phi = lat*rad;
        const d = toDays(dateUTC);
        const n = Math.round(d - J0 - lw/(2*Math.PI));
        const ds = approxTransit(0, lw, n);
        const M = solarMeanAnomaly(ds);
        const L = eclipticLongitude(M);
        const dec = declination(L, 0);
        const Jnoon = solarTransitJ(ds, M, L);
        const h0 = (-0.833) * rad;
        const w0 = hourAngle(h0, phi, dec);
        if (isNaN(w0)) return { sunrise:null, solarNoon:fromJulian(Jnoon), sunset:null };
        const Jrise = solarTransitJ(approxTransit(-w0, lw, n), M, L);
        const Jset  = solarTransitJ(approxTransit( w0, lw, n), M, L);
        return { sunrise: fromJulian(Jrise), solarNoon: fromJulian(Jnoon), sunset: fromJulian(Jset) };
      }

      const sunriseEl = document.getElementById('sunrise');
      const solarNoonEl = document.getElementById('solarNoon');
      const sunsetEl = document.getElementById('sunset');


        const [lon,lat]=ll;
        const {Y,Mo,D}= getPartsForTZ(currentTZ);
        const baseUTC = new Date(Date.UTC(Y,Mo-1,D,12,0,0));
        const t = getSunTimes(baseUTC, lat, lon);
        const fmt = d => d ? d.toLocaleTimeString('en-GB',{timeZone: currentTZ, hour:'2-digit', minute:'2-digit'}) : '--';
        sunriseEl.textContent = fmt(t.sunrise);
        solarNoonEl.textContent = fmt(t.solarNoon);
        sunsetEl.textContent  = fmt(t.sunset);
      }
      window.updateSunTimes = updateSunTimes;

      const marker = g.append("circle").attr("class","city-marker").attr("r",6).attr("opacity",1);

      function updateCityMarker(cityName){
        const ll=CITY_COORDS[cityName];
        if(!ll) {
          console.warn(`No coordinates found for ${cityName}, using Geneva`);
          currentCityLL = [6.15, 46.2];
        } else {
          currentCityLL = ll;
        }
        const [x,y]=projection(currentCityLL);
        marker.attr("cx",x).attr("cy",y).attr("opacity",1);
        if (!window.__isAnimatingMarker) {
          setTimeout(()=>{ if(window.pulseMarker) window.pulseMarker(true); }, 20);
        }
      }
      window.updateCityMarker = updateCityMarker;

      const toRad = Math.PI/180;
      /* const ALT_CORR_DEG = 0.833; */
      const ALT_CORR_DEG = 0;
      const ALT_CORR_RAD = ALT_CORR_DEG * toRad;

      function subsolar(date){
        const d = toDays(date);
        const M = solarMeanAnomaly(d);
        const L = eclipticLongitude(M);
        const dec = declination(L, 0);
        const ra  = rightAscension(L, 0);
        const JD = toJulian(date.getTime());
        const T = (JD - 2451545.0) / 36525.0;
        let GMST = 280.46061837 + 360.98564736629*(JD-2451545.0) + 0.000387933*T*T - T*T*T/38710000.0;
        GMST = ((GMST%360)+360)%360 * Math.PI/180;
        let lon = (ra - GMST);
        lon = ((lon + Math.PI*3)%(2*Math.PI)) - Math.PI;
        const lat = dec;
        return { lon: lon*180/Math.PI, lat: lat*180/Math.PI };
      }

    
        if (!currentCityLL){
          updateCityMarker(cityName);
          if (window.updateSunTimes) window.updateSunTimes(cityName);
          const subNow = subsolar(new Date());
          updateMarkerColor(subNow);
          return;
        }

        window.__isAnimatingMarker = true;
        const _cityDot = document.querySelector('.city-marker');
        if (_cityDot) _cityDot.classList.remove('pulse');

        const interp = d3.geoInterpolate(currentCityLL, target);
        const t0 = performance.now();

        function step(now){
          const u = Math.min(1, (now - t0) / duration);
          const ll = interp(u);
          const [x, y] = projection(ll);
          marker.attr("cx", x).attr("cy", y).attr("opacity", 1);
          const sub = subsolar(new Date());
          const night = isNightAt(ll, sub);
          marker.attr("fill", night ? "yellow" : "red");

          if (u < 1){ requestAnimationFrame(step); }
          else{
            window.__isAnimatingMarker = false;
            currentCityLL = target.slice();
            if (window.updateSunTimes) window.updateSunTimes(cityName);
            if (window.pulseMarker) window.pulseMarker(true);
          }
        }
        requestAnimationFrame(step);
      };

      function placeInitialMarker(){
        const currentCity=document.getElementById('city').textContent.trim();
        updateCityMarker(currentCity);
        updateSunTimes(currentCity);
        const sub0 = subsolar(new Date());
        updateMarkerColor(sub0);
      }
      placeInitialMarker();

      const cmpMarker = g.append("circle").attr("class","compare-marker").attr("r",6).attr("opacity",0);
      const lineDay   = g.append("path").attr("class","compare-line").attr("stroke","red").attr("stroke-width",3).attr("mask","url(#dayMask)");
      const lineNight = g.append("path").attr("class","compare-line").attr("stroke","yellow").attr("stroke-width",3).attr("mask","url(#nightMask)");
      let compareCityLL = null;

      function updateCompareGraphics(){
        if(!currentCityLL || !compareCityLL){
          cmpMarker.attr("opacity",0);
          lineDay.attr("d", null); lineNight.attr("d", null);
          return;
        }
        const [x2,y2] = projection(compareCityLL);
        cmpMarker.attr("cx",x2).attr("cy",y2).attr("opacity",1);
        const sub = subsolar(new Date());
        const isNightCmp = isNightAt(compareCityLL, sub);
        cmpMarker.attr("fill", isNightCmp ? "yellow" : "red");
        const interp = d3.geoInterpolate(currentCityLL, compareCityLL);
        const coords = d3.range(0, 1.0001, 0.02).map(t => interp(t));
        const lineGeo = { type:"LineString", coordinates: coords };
        lineDay.attr("d", path(lineGeo));
        lineNight.attr("d", path(lineGeo));
      }

      window.updateCompare = function(cityName){
        if (!cityName){
          compareCityLL = null;
          updateCompareGraphics();
          return;
        }
        const ll = CITY_COORDS[cityName];
        if (!ll) {
          console.warn(`No coordinates found for comparison city ${cityName}`);
          compareCityLL = null;
        } else {
          compareCityLL = ll.slice();
        }
        updateCompareGraphics();
      };

      const crossDay   = g.append('g').attr('class','close-cross-day').attr('mask','url(#dayMask)').style('pointer-events','none');
      const crossNight = g.append('g').attr('class','close-cross-night').attr('mask','url(#nightMask)').style('pointer-events','none');

      function drawCloseCross(){
        const svgNode = document.getElementById('map');
        const rect = svgNode.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) return;

        const rootStyle = getComputedStyle(document.documentElement);
        const offX = parseFloat(rootStyle.getPropertyValue('--close-offset-x')) || 5;
        const offY = parseFloat(rootStyle.getPropertyValue('--close-offset-y')) || 15;
        const sizePx   = parseFloat(rootStyle.getPropertyValue('--close-size'))   || 28;
        const strokePx = parseFloat(rootStyle.getPropertyValue('--close-stroke')) || 5;
        const colorDay   = (rootStyle.getPropertyValue('--close-color-day')   || 'red').trim();
        const colorNight = (rootStyle.getPropertyValue('--close-color-night') || 'yellow').trim();

        const scaleX = rect.width / width;
        const scaleY = rect.height / height;
        const scale = Math.min(scaleX, scaleY);

        const cx_px = offX + sizePx/2;
        const cy_px = rect.height - offY - sizePx/2;

        const cx = cx_px / scale;
        const cy = cy_px / scale;
        const half = (sizePx/2) / scale;
        const sw = strokePx / scale;

        crossDay.selectAll('*').remove();
        crossNight.selectAll('*').remove();

        const lines = [
          { x1: cx - half, y1: cy - half, x2: cx + half, y2: cy + half },
          { x1: cx - half, y1: cy + half, x2: cx + half, y2: cy - half }
        ];

        lines.forEach(l=>{
          crossDay.append('line')
            .attr('x1', l.x1).attr('y1', l.y1).attr('x2', l.x2).attr('y2', l.y2)
            .attr('stroke', colorDay).attr('stroke-width', sw).attr('stroke-linecap','round');
          crossNight.append('line')
            .attr('x1', l.x1).attr('y1', l.y1).attr('x2', l.x2).attr('y2', l.y2)
            .attr('stroke', colorNight).attr('stroke-width', sw).attr('stroke-linecap','round');
        });
      }

   

      const observer = new MutationObserver(()=> {
        if (window.__skipNextCityMutation){
          window.__skipNextCityMutation = false;
          return;
        }
        const city = document.getElementById('city').textContent.trim();
        updateCityMarker(city);
        updateCompareGraphics();
        const sub = subsolar(new Date());
        updateMarkerColor(sub);
      });
      observer.observe(document.getElementById('city'), { childList:true, characterData:true, subtree:true });

      window.addEventListener('resize', drawCloseCross);
      drawCloseCross();
    })();
  </script>

  <script>
    if("serviceWorker" in navigator){ navigator.serviceWorker.register("/sw.js"); }
  </script>

  <script>
    (function () {
      var btn = document.getElementById('showMapBtn');
      var area = document.getElementById('mapArea');
      var closeBtn = document.getElementById('closeMapBtn');
      if (!btn || !area) return;

      function onOpen(){
        btn.style.display = 'none';
        area.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';
        try {
            window.dispatchEvent(new Event('resize'));
        } catch (e) {}

      btn.addEventListener('click', onOpen);

      if (closeBtn){
        closeBtn.addEventListener('click', function(){
          area.style.display = 'none';
          btn.style.display = 'block';
          closeBtn.style.display = 'none';
        });
      }
    })();
  </script>
  <script>
    (function(){
      var rb = document.getElementById('resetBtn');
      if (rb) {
        rb.addEventListener('click', function(){
          if (window.resetDiff) window.resetDiff();
        });
      }
    })();
  </script>

</body>
</html>
