<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Globe terrestre avec capitales</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: white;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      touch-action: none;
    }
    .smartphone-frame {
      position: relative;
      width: 22vw;
      height: 85vh;
      border: 3px solid black;
      border-radius: 40px;
      overflow: hidden;
      box-shadow: 0 0 25px rgba(0,0,0,0.4);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      transform-origin: center center;
    }
    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      transform: translate(-50%, -50%);
      z-index: 10;
    }
    .crosshair::before,
    .crosshair::after {
      content: "";
      position: absolute;
      background: red;
    }
    .crosshair::before { width: 20px; height: 1px; left: -10px; top: 0; }
    .crosshair::after { width: 1px; height: 20px; top: -10px; left: 0; }
    #cartouche {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 6px 14px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      font-family: Arial, sans-serif;
      font-size: 1.1em;
      color: #111;
      pointer-events: none;
      min-width: 120px;
      text-align: center;
      z-index: 20;
      display: none;
    }
  </style>
</head>
<body>
  <div class="smartphone-frame">
    <canvas id="c"></canvas>
    <div class="crosshair"></div>
    <div id="cartouche"></div>
  </div>

  <script src="https://unpkg.com/topojson-client@3"></script>

  <script type="module">
  import * as THREE from "./three.module.js";

  const canvas = document.getElementById("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0xffffff, 1);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
  camera.position.z = 0.7;

  const light = new THREE.DirectionalLight(0xffffff, 0.8);
  light.position.set(2, 2, 3);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff, 0.9));

  const radius = 0.14;

  const textureCanvas = document.createElement('canvas');
  textureCanvas.width = 4096;
  textureCanvas.height = 2048;
  const ctx = textureCanvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  ctx.fillStyle = '#4aa8ff';
  ctx.fillRect(0, 0, textureCanvas.width, textureCanvas.height);

  const texture = new THREE.CanvasTexture(textureCanvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.ClampToEdgeWrapping;
  
  const sphere = new THREE.Mesh(
    new THREE.SphereGeometry(radius, 256, 256),
    new THREE.MeshBasicMaterial({ map: texture })
  );
  scene.add(sphere);

  let zoom = 0.7;
  let lastDistance = null;
  let currentHighlightedCountry = null;

  window.addEventListener("wheel", e => {
    e.preventDefault();
    zoom += e.deltaY * 0.0005;
    zoom = Math.min(Math.max(0.3, zoom), 2.0);
    camera.position.z = zoom;
  }, { passive: false });

  window.addEventListener("touchstart", e => {
    if (e.touches.length === 2) {
      const dx = e.touches[0].pageX - e.touches[1].pageX;
      const dy = e.touches[0].pageY - e.touches[1].pageY;
      lastDistance = Math.sqrt(dx * dx + dy * dy);
    }
  });

  window.addEventListener("touchmove", e => {
    if (e.touches.length === 2 && lastDistance) {
      const dx = e.touches[0].pageX - e.touches[1].pageX;
      const dy = e.touches[0].pageY - e.touches[1].pageY;
      const newDistance = Math.sqrt(dx * dx + dy * dy);
      const delta = lastDistance - newDistance;
      zoom += delta * 0.0005;
      zoom = Math.min(Math.max(0.3, zoom), 2.0);
      camera.position.z = zoom;
      lastDistance = newDistance;
    }
  });

  let countriesGeoJSON = null;
  let capitalsData = null;
  let overridesData = null;

  async function loadCountries() {
    const response = await fetch("countries.json");
    const world = await response.json();
    countriesGeoJSON = topojson.feature(world, world.objects.countries);
    drawCountriesOnTexture(countriesGeoJSON);
    texture.needsUpdate = true;
    drawBorders(countriesGeoJSON);
  }

  async function loadCapitals() {
    const response = await fetch("countries_OK.json");
    capitalsData = await response.json();
    drawCapitals(capitalsData);
  }

  async function loadOverrides() {
    try {
      const response = await fetch("capitals_overrides.json");
      overridesData = await response.json();
    } catch (e) {
      console.error("Erreur chargement overrides:", e);
    }
  }

  function latLonToXYZ(lat, lon, r) {
    const phi = (90 - lat) * Math.PI / 180;
    const theta = (lon + 180) * Math.PI / 180;
    return new THREE.Vector3(
      -r * Math.sin(phi) * Math.cos(theta),
      r * Math.cos(phi),
      r * Math.sin(phi) * Math.sin(theta)
    );
  }

  function XYZToLatLon(vec) {
    const r = Math.sqrt(vec.x*vec.x + vec.y*vec.y + vec.z*vec.z);
    const lat = Math.asin(vec.y/r) * 180 / Math.PI;
    const lon = Math.atan2(vec.z, -vec.x) * 180 / Math.PI - 180;
    return { lat, lon };
  }

  function drawCountriesOnTexture(geojson) {
    ctx.fillStyle = '#ffffff';
    geojson.features.forEach(feature => {
      const geometry = feature.geometry;
      if (geometry.type === "Polygon") {
        drawCountryOnTexture(geometry.coordinates);
      } else if (geometry.type === "MultiPolygon") {
        geometry.coordinates.forEach(polygon => drawCountryOnTexture(polygon));
      }
    });
  }

  function drawCountryOnTexture(coordinates) {
    coordinates.forEach(ring => {
      ctx.beginPath();
      let validPath = false;
      ring.forEach(([lon, lat], i) => {
        lon = Math.max(-180, Math.min(180, lon));
        lat = Math.max(-90, Math.min(90, lat));
        
        const x = ((lon + 180) / 360) * textureCanvas.width;
        const y = ((90 - lat) / 180) * textureCanvas.height;
        if (!validPath) {
          ctx.moveTo(x, y);
          validPath = true;
        } else {
          ctx.lineTo(x, y);
        }
      });
      if (validPath) {
        ctx.closePath();
        ctx.fill();
      }
    });
  }

  function highlightCountry(countryName) {
    if (!countriesGeoJSON) return;
    
    ctx.fillStyle = '#4aa8ff';
    ctx.fillRect(0, 0, textureCanvas.width, textureCanvas.height);
    
    countriesGeoJSON.features.forEach(feature => {
      const isHighlighted = feature.properties.name === countryName;
      ctx.fillStyle = isHighlighted ? '#FEA347' : '#ffffff';
      const geometry = feature.geometry;
      if (geometry.type === "Polygon") {
        drawCountryOnTexture(geometry.coordinates);
      } else if (geometry.type === "MultiPolygon") {
        geometry.coordinates.forEach(polygon => drawCountryOnTexture(polygon));
      }
    });
    
    texture.needsUpdate = true;
  }

  function drawBorders(geojson) {
    geojson.features.forEach(feature => {
      const geometry = feature.geometry;
      if (geometry.type === "Polygon") {
        drawBorder(geometry.coordinates);
      } else if (geometry.type === "MultiPolygon") {
        geometry.coordinates.forEach(polygon => drawBorder(polygon));
      }
    });
  }

  function drawBorder(coordinates) {
    coordinates.forEach(ring => {
      const validPoints = ring.filter(([lon, lat]) => 
        lon >= -180 && lon <= 180 && lat >= -90 && lat <= 90
      );
      
      if (validPoints.length < 2) return;
      
      const points = validPoints.map(([lon, lat]) => latLonToXYZ(lat, lon, radius * 1.004));
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      const mat = new THREE.LineBasicMaterial({ color: 0x333333 });
      const line = new THREE.Line(geo, mat);
      sphere.add(line);
    });
  }

  function drawCapitals(capitalsArray) {
    capitalsArray.forEach(c => {
      const pos = latLonToXYZ(c.lat, c.lon, radius * 1.01);
      const dotGeo = new THREE.CircleGeometry(0.0012, 16);
      const dotMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
      const dot = new THREE.Mesh(dotGeo, dotMat);
      dot.position.copy(pos);
      dot.lookAt(0, 0, 0);
      dot.rotateY(Math.PI);
      sphere.add(dot);
    });
  }

  function findCapitalForCountry(countryName) {
    if (!countryName) return null;
    const normalize = str => str.toLowerCase().replace(/[^a-z]/g, "");
    if (overridesData) {
      const found = overridesData.find(
        o => normalize(o.country) === normalize(countryName) ||
             normalize(o.key || "") === normalize(countryName)
      );
      if (found && found.capital) return found.capital;
    }
    if (capitalsData) {
      const searchMapping = { "Côte d'Ivoire": "Ivory Coast", "Guyane française": "French Guiana" };
      const searchName = searchMapping[countryName] || countryName;
      const c = capitalsData.find(x => normalize(x.country) === normalize(searchName));
      if (c && c.capital) return c.capital;
    }
    return null;
  }

  function normalizeLongitude(lon) {
    while (lon < -180) lon += 360;
    while (lon > 180) lon -= 360;
    return lon;
  }

  function findCountryAtPoint(lat, lon) {
    if (!countriesGeoJSON) return null;
    lon = normalizeLongitude(lon);
    const point = [lon, lat];
    for (const feature of countriesGeoJSON.features) {
      const geometry = feature.geometry;
      if (!geometry) continue;
      if (geometry.type === "Polygon") {
        for (const ring of geometry.coordinates) {
          if (pointInPolygon(point, ring)) return feature.properties.name;
        }
      } else if (geometry.type === "MultiPolygon") {
        for (const polygon of geometry.coordinates) {
          for (const ring of polygon) {
            if (pointInPolygon(point, ring)) return feature.properties.name;
          }
        }
      }
    }
    return null;
  }

  function pointInPolygon(point, polygon) {
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i][0], yi = polygon[i][1];
      const xj = polygon[j][0], yj = polygon[j][1];
      const intersect = ((yi > point[1]) !== (yj > point[1])) &&
        (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi + 1e-10) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function updateCountryDisplay() {
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObject(sphere);
    const cartouche = document.getElementById("cartouche");
    if (intersects.length > 0) {
      const point = intersects[0].point;
      const localPoint = sphere.worldToLocal(point.clone());
      const coords = XYZToLatLon(localPoint);
      let countryName = findCountryAtPoint(coords.lat, coords.lon);
      if (countryName) {
        if (currentHighlightedCountry !== countryName) {
          currentHighlightedCountry = countryName;
          highlightCountry(countryName);
        }
        const frenchToEnglish = {
          "Côte d'Ivoire": "Ivory Coast", "Guyane française": "French Guiana", "Guadeloupe": "Guadeloupe",
          "Martinique": "Martinique", "La Réunion": "Réunion", "Réunion": "Réunion", "Mayotte": "Mayotte",
          "Nouvelle-Calédonie": "New Caledonia", "Polynésie française": "French Polynesia", "Saint-Martin": "Saint Martin",
          "Saint-Barthélemy": "Saint Barthélemy", "Saint-Pierre-et-Miquelon": "Saint Pierre and Miquelon",
          "Bermudes": "Bermuda", "Gibraltar": "Gibraltar", "Îles Malouines": "Falkland Islands",
          "Îles Vierges britanniques": "British Virgin Islands", "Îles Caïmans": "Cayman Islands",
          "Anguilla": "Anguilla", "Montserrat": "Montserrat",
          "Géorgie du Sud et les îles Sandwich du Sud": "South Georgia",
          "Groenland": "Greenland", "Guam": "Guam", "Porto Rico": "Puerto Rico",
          "Samoa américaines": "American Samoa", "Îles Vierges américaines": "United States Virgin Islands",
          "Îles Mariannes du Nord": "Northern Mariana Islands", "Chypre": "Cyprus",
          "Hong Kong": "Hong Kong", "Macao": "Macao", "Svalbard": "Svalbard and Jan Mayen", "France": "France"
        };
        const displayName = frenchToEnglish[countryName] || countryName;
        const capital = findCapitalForCountry(countryName);
        cartouche.style.display = "block";
        cartouche.textContent = capital ? `${displayName} (${capital})` : displayName;
      } else {
        if (currentHighlightedCountry !== null) {
          currentHighlightedCountry = null;
          highlightCountry(null);
        }
        cartouche.style.display = "none";
      }
    } else {
      if (currentHighlightedCountry !== null) {
        currentHighlightedCountry = null;
        highlightCountry(null);
      }
      cartouche.style.display = "none";
    }
  }

  let dragging = false, lastX = 0, lastY = 0;
  function rotateSphere(dx, dy) {
    sphere.rotation.y += dx * 0.01;
    sphere.rotation.x += dy * 0.01;
    updateCountryDisplay();
  }

  canvas.addEventListener("mousedown", e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
  window.addEventListener("mouseup", () => { dragging = false; updateCountryDisplay(); });
  window.addEventListener("mousemove", e => {
    if (dragging) {
      rotateSphere(e.clientX - lastX, e.clientY - lastY);
      lastX = e.clientX;
      lastY = e.clientY;
    }
  });

  canvas.addEventListener("wheel", e => e.preventDefault(), { passive: false });

  function animate() {
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  loadCountries();
  loadCapitals();
  loadOverrides();
  animate();
  setTimeout(updateCountryDisplay, 500);

  window.addEventListener("resize", () => {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  });
  </script>
</body>
</html>