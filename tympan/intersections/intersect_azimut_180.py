{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b959fcec-82cf-4f68-9480-14fb4d2818d6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Entrez la latitude en degr√©s d√©cimaux (ex: 46.2) :  5\n"
     ]
    },
    {
     "ename": "TypeError",
     "evalue": "'float' object cannot be interpreted as an integer",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mTypeError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[1]\u001b[39m\u001b[32m, line 35\u001b[39m\n\u001b[32m     32\u001b[39m resultats = []\n\u001b[32m     34\u001b[39m \u001b[38;5;66;03m# ‚úÖ Donn√©es r√©elles (Z = 0 √† 65)\u001b[39;00m\n\u001b[32m---> \u001b[39m\u001b[32m35\u001b[39m Z_reels = \u001b[38;5;28mlist\u001b[39m(\u001b[38;5;28;43mrange\u001b[39;49m\u001b[43m(\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m66\u001b[39;49m\u001b[43m \u001b[49m\u001b[43m+\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m0.1\u001b[39;49m\u001b[43m)\u001b[49m)\n\u001b[32m     36\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m Z \u001b[38;5;129;01min\u001b[39;00m Z_reels:\n\u001b[32m     37\u001b[39m     cercle = alm.calculer_almucantarat(Z)\n",
      "\u001b[31mTypeError\u001b[39m: 'float' object cannot be interpreted as an integer"
     ]
    }
   ],
   "source": [
    "# üìÅ Ajout du chemin vers le projet Flask\n",
    "import sys\n",
    "import os\n",
    "\n",
    "chemin_projet = r\"C:\\Users\\admin\\Dropbox\\00e-NET\\0PROJETS\\0ASTROLABE\\00pythonAstrolabe2\"\n",
    "sys.path.append(chemin_projet)\n",
    "\n",
    "# üì¶ Imports\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.linear_model import LinearRegression\n",
    "from sklearn.preprocessing import PolynomialFeatures\n",
    "from sklearn.pipeline import make_pipeline\n",
    "from sklearn.metrics import r2_score\n",
    "\n",
    "from tympan.almucantarats.almucantarats import Almucantarats\n",
    "\n",
    "# üì• Demande de la latitude\n",
    "latitude_input = input(\"Entrez la latitude en degr√©s d√©cimaux (ex: 46.2) : \")\n",
    "try:\n",
    "    latitude = float(latitude_input)\n",
    "except ValueError:\n",
    "    print(\"Latitude invalide.\")\n",
    "    latitude = None\n",
    "\n",
    "# üìê Param√®tres identiques √† views.py\n",
    "rayon_equateur = 6\n",
    "\n",
    "if latitude is not None:\n",
    "    alm = Almucantarats(rayon_equateur, latitude)\n",
    "    resultats = []\n",
    "\n",
    "    # ‚úÖ Donn√©es r√©elles (Z = 0 √† 65)\n",
    "    Z_reels = list(range(0, 66 + 1, 1))\n",
    "    for Z in Z_reels:\n",
    "        cercle = alm.calculer_almucantarat(Z)\n",
    "        if cercle:\n",
    "            y_cartesien = cercle[\"cy\"] - cercle[\"rayon\"]\n",
    "            resultats.append({\n",
    "                \"Z\": Z, \n",
    "                \"y_cartesien\": y_cartesien, \n",
    "                \"rayon\": cercle[\"rayon\"],\n",
    "                \"centre_y\": cercle[\"cy\"],\n",
    "                \"extrapole\": False\n",
    "            })\n",
    "\n",
    "    # üìà R√©gression polynomiale\n",
    "    df_reel = pd.DataFrame(resultats)\n",
    "    X = df_reel[[\"Z\"]]\n",
    "    y = df_reel[\"y_cartesien\"]\n",
    "\n",
    "    # üîé Tester plusieurs degr√©s pour trouver R¬≤ = 1\n",
    "    meilleur_modele = None\n",
    "    meilleur_degre = None\n",
    "    for degre in range(1, 20):\n",
    "        modele = make_pipeline(PolynomialFeatures(degre), LinearRegression())\n",
    "        modele.fit(X, y)\n",
    "        y_pred = modele.predict(X)\n",
    "        r2 = r2_score(y, y_pred)\n",
    "        if np.isclose(r2, 1.0, atol=1e-12):\n",
    "            meilleur_modele = modele\n",
    "            meilleur_degre = degre\n",
    "            break\n",
    "\n",
    "    if meilleur_modele is not None:\n",
    "        # üßÆ Formule + extrapolation\n",
    "        coeffs = meilleur_modele.named_steps['linearregression'].coef_\n",
    "        intercept = meilleur_modele.named_steps['linearregression'].intercept_\n",
    "        formule = f\"y = {intercept:.4f} \" + \" \".join(\n",
    "            [f\"+ {coeffs[i]:.4f}¬∑Z^{i}\" for i in range(1, len(coeffs))]\n",
    "        )\n",
    "\n",
    "        # ‚ûï Extrapoler pour Z = -6, -12, -18\n",
    "        for Z_ext in [-6, -12, -18]:\n",
    "            y_ext = meilleur_modele.predict(pd.DataFrame({\"Z\": [Z_ext]}))[0]\n",
    "            resultats.append({\n",
    "                \"Z\": Z_ext,\n",
    "                \"y_cartesien\": y_ext,\n",
    "                \"rayon\": np.nan,\n",
    "                \"centre_y\": np.nan,\n",
    "                \"extrapole\": True\n",
    "            })\n",
    "\n",
    "        # üìã Tableau final\n",
    "        df_all = pd.DataFrame(resultats).sort_values(by=\"Z\", ascending=True)\n",
    "        from IPython.display import display\n",
    "        display(df_all[[\"Z\", \"y_cartesien\"]])  # rayon et centre supprim√©s\n",
    "\n",
    "        # üìä Affichage graphique\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        for _, row in df_all.iterrows():\n",
    "            color = 'red' if row[\"extrapole\"] else 'blue'\n",
    "            plt.scatter(row[\"Z\"], row[\"y_cartesien\"], color=color)\n",
    "\n",
    "        Z_plot = pd.DataFrame({\"Z\": np.linspace(-20, 70, 200)})\n",
    "        y_plot = meilleur_modele.predict(Z_plot)\n",
    "        plt.plot(Z_plot[\"Z\"], y_plot, color='green', label=f\"R√©gression (R¬≤ = 1, degr√© {meilleur_degre})\")\n",
    "\n",
    "        plt.title(\"Coordonn√©es Y cart√©siennes des intersections\")\n",
    "        plt.xlabel(\"Z (hauteur en ¬∞)\")\n",
    "        plt.ylabel(\"y cart√©sien\")\n",
    "        plt.grid(True)\n",
    "        plt.legend()\n",
    "\n",
    "        plt.text(0.05, 0.95, formule, fontsize=9, transform=plt.gca().transAxes, verticalalignment='top')\n",
    "        plt.text(0.05, 0.90, f\"R¬≤ = 1.0 (degr√© {meilleur_degre})\", fontsize=9, transform=plt.gca().transAxes, verticalalignment='top')\n",
    "\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "    else:\n",
    "        print(\"‚ö†Ô∏è Aucun mod√®le avec R¬≤ = 1 trouv√©.\")\n",
    "else:\n",
    "    print(\"‚ùå Latitude invalide. Aucun calcul effectu√©.\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
